3.5 Registers


### 3.5 寄存器

#### 3.5.1 寄存器文件银行

Turing和Volta在每个处理块中使用一个物理寄存器文件，包含16,384个32位元素。线程可见的逻辑寄存器以8为增量进行分配，或者以256为总增量分配给一个warp中的所有32个线程。这些寄存器文件被组织成2个银行，每个银行有2个32位端口，逻辑寄存器属于与它们名称模2匹配的银行。每个端口每个时钟周期只能满足一个32位读取操作，如果编译后的代码中的指令（例如，单精度浮点融合乘加指令FFMA）需要三个或更多的操作数，而所有这些源寄存器的名称都映射到同一个双端口银行，则会由于寄存器银行冲突而导致执行停顿。

例如：

- 指令`FFMA R15, R11, R12, R13`不会发生冲突，因为源操作数R11和R13可以从银行1的两个端口获取，R12可以从银行0的一个端口获取，而目标寄存器R15不会使用银行1的额外端口；
- 指令`FFMA R18, R10, R12, R16`会发生冲突，因为R10、R12和R16都在银行0中。（目标寄存器R18无关紧要。）

在我们的关于Volta的技术报告[2]中，我们通过仔细重新分配寄存器以最小化银行冲突，展示了高达15%的性能提升。

图3.10展示了寄存器银行冲突对T4 GPU上指令延迟的影响。我们使用长序列的相同FFMA指令进行基准测试，并改变其中一个源寄存器索引（RX）以引起冲突。由于T4 GPU具有双端口寄存器银行，只有当FFMA指令中的所有三个32位源寄存器都属于同一个银行时，才会发生冲突。在形式为`FFMA R6, R97, R99, RX`的指令序列中，R97和R99位于银行1；如果RX也位于银行1，则会发生冲突。（R6无关紧要，因为它是目标寄存器。）在形式为`FFMA R6, R98, R99, RX`的指令序列中，由于R98和R99位于不同的银行，因此无论RX的值如何，都无法引起三个读取操作来自同一个银行的冲突。

#### 3.5.2 统一寄存器

根据NVIDIA的文档，Turing引入了一个新特性，旨在提高主浮点运算路径的最大可实现算术吞吐量，方法是添加一个单独的、仅支持整数的标量数据路径（称为统一数据路径），该路径与主数据路径并行运行。

这种设计旨在加速那些几乎完全占用主数据路径的数值型、基于数组的、计算密集型工作负载，这些工作负载通常包含一些整数运算，例如更新数组索引、循环索引或指针，或者执行数组或循环边界检查。这些少量的整数指令会破坏指令组合，从而显著降低主数据路径的整体算术吞吐量，使其远低于理论最大值。

在Turing上，编译器可以选择将这些整数操作推送到单独的统一数据路径上，从而避免它们干扰主数据路径。为此，编译器必须生成统一数据路径指令。

常规指令可以访问统一寄存器和常规寄存器。统一数据路径指令则几乎只关注统一指令。

尽管我们目前尚未能够通过编译器生成统一数据路径指令，但我们通过系统地反汇编打包的统一指令，枚举了Turing支持的64个统一寄存器（包括统一零寄存器URZ和63个通用统一寄存器UR0–UR62）。

#### 3.5.3 常规寄存器

Turing上的指令仍然支持256个常规寄存器（包括通用寄存器R0–R254和零寄存器RZ）。

我们发现，`cuobjdump -dump-resource-usage`命令（该命令打印内核的寄存器使用情况）报告的寄存器数量包括常规寄存器和统一寄存器。任何CUDA内核中使用的寄存器总数上限为256，与Volta相同。

我们通过修改CUDA内核的节头中的寄存器计数，将其设置为超过256的值，并确定`cuobjdump`最多只识别256个寄存器，从而验证了这一结果。
