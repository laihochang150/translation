Chapter 2
How Turing encodes instructions

### 第2章 Turing如何编码指令

通过系统地反汇编我们手工编写的机器代码，以及从代表性CUDA库中采样的代码，使用`cuobjdump`和`nvdisasm`，我们发现了不同GPU架构所采用的指令编码格式。Turing采用了与Volta相同的格式，这与Pascal和Maxwell（它们又与Kepler不同）形成了显著差异，我们在本章中详细阐述了这些差异。

Turing和Volta使用128位来编码一条指令及其相关的调度控制信息。这与之前NVIDIA GPU架构有显著不同，后者使用一个字（64位）来编码纯指令信息，并在每几条指令后使用一个单独的64位字来编码与这些指令相关的控制信息。

以下示例展示了由`nvdisasm`解码的Turing/Volta指令及其控制信息：

```
S2UR UR4, SR_CLOCKLO ;
```

```
Instruction Part 1 /*0x00000000000479c3*/ /*0x0000240000005000*/ Instruction Part 2 Control Logic
```

输出显示指令被解码为两个64位字。第一个字包含纯指令信息，而第二个字则包含指令和控制信息。

基于指令反汇编和任意代码执行的实验表明，这128位的编码方式如下：

- 至少91位用于指令信息；
- 至少23位用于控制信息；
- 剩余的14位在Turing和Volta中似乎未被使用；在我们的实验中，这些位被`cuobjdump`和硬件所忽略。

: 在这里，我们所说的控制信息是指编译器做出的指令调度决策，这些决策必须由硬件来执行；下一节将详细讨论这一主题。

#### 2.1 控制信息

控制字首次出现在Kepler架构中，它用软件调度取代了动态硬件调度。控制字编码了编译器做出的指令调度决策，这些决策必须由硬件执行。在Kepler的设计中，用软件调度取代复杂硬件调度器的决定，标志着与之前设计（Fermi）的背离：设计者们用一个更简单、更高效的调度器替换了复杂的硬件调度器，该调度器占用的硅片面积更小，功耗也更低。总体而言，软件调度使得芯片上的控制逻辑更加简化，从而在每单位硅片面积上实现了更高的计算密度和更好的能效。

在Turing和Volta上，128位包含了与单条指令相关联的指令和控制信息。

在Pre-Volta架构中，一个控制字与多个指令字打包成一个“束”。在每个束中，第一个字（以十六进制形式显示但没有对应的反汇编指令）是控制字，其余的字（Pascal和Maxwell中有3个，Kepler中有7个）分别编码一条指令。每个控制字影响架构对束内指令的调度方式。

以下摘录展示了由`nvdisasm`解码的Pascal指令束。该束包含四个64位字。第一个字（有十六进制转储但没有对应的反汇编指令）是控制字，其余三个字是指令。

```
|Col1|Col2|Col3|Col4|/*|0x000f8800fe2007f1|*/|
|---|---|---|---|---|---|---|
|/*0288*/|@P5|LDG.E.CI|R66, [R86+0x100];|/*|0xeed4a00010055642|*/|
|/*0290*/|@!P5|MOV R66,|RZ;|/*|0x5c9807800ffd0042|*/|
|/*0298*/|@P6|LDG.E.CI|R67, [R86+0x180];|/*|0xeed4a00018065643|*/|
```

控制信息在不同GPU代上的编码方式如下：

- 在Kepler上，每个控制字的最高有效位有6个零，最低有效位有2个零，中间有7个8位的段；
- 在Pascal和Maxwell上，每个控制字的最高有效位有1个零，后面跟着3个21位的段；
- 在Turing和Volta上，每个控制段的最高有效位有2个零，后面跟着1个21位的段。对于每128位对应的一条指令，控制信息位于指令本身的编码之前和之后。

控制信息的各个部分在Turing、Volta、Pascal和Maxwell上都以相同的方式组织。每个部分包含6个字段，组织如下：

|4|6|3|3|1|4|
|---|---|---|---|---|---|
|||||||
|重用|等待|读取|写入|让出|停顿|
|标志|屏障|屏障|屏障|标志|周期|
||掩码|索引|索引|||

字段的含义如下：

重用标志：Turing、Volta、Pascal和Maxwell上的每个硬件线程都有一个2路关联的内容寻址存储器（CAM），用于每个概念上的四个源操作数位置。此存储器旨在允许在不访问任何寄存器端口的情况下重用数据，从而减轻寄存器文件的压力，并帮助减少寄存器银行冲突（我们将在第3.5.1节中详细讨论寄存器银行冲突）。重用标志控制此机制，如下所示：指令可以标记将其多达前四个参数中的任意组合保存到重用集中。每个指令都会尝试从相应的重用槽中读取其前四个参数，如果失败，则通过寄存器文件端口加载值。例如，如果第二个指令源操作数位置中最后两个重用保存的寄存器是R98和R99，则可以在不增加寄存器银行冲突的情况下使用这两个寄存器中的任意一个。重用标志的四个位分别映射到第一到第四个源操作数，从最低有效位到最高有效位。

等待屏障掩码；读取/写入屏障索引。虽然大多数指令具有固定的延迟，可以由汇编器静态调度，但涉及内存和共享资源的指令通常具有可变延迟。Turing、Volta、Pascal和Maxwell使用依赖屏障来跟踪可变延迟指令的完成情况，并解决数据相关性问题。当可变延迟指令写入寄存器时，汇编器会将其与一个可用的屏障关联起来，通过设置相应的写入屏障编号字段来实现。当后续指令使用该寄存器时，汇编器会通过在等待屏障掩码中设置相应位来标记该指令正在等待该屏障。硬件会在早期指令的结果可用之前暂停后续指令。一个指令可以等待多个屏障，这解释了为什么等待屏障掩码是一个位掩码，而不是一个索引。

读取依赖屏障。读取依赖屏障的作用是防止写后读相关性问题。未缓冲的指令将寄存器的内容写入内存时，需要寄存器在整个操作过程中保持不变。为了保证这一点，汇编器会通过填充相应的读取屏障编号字段，将这些指令与一个屏障关联起来。后续写入同一寄存器的指令将等待该屏障。

停顿周期。这个4位字段指示调度器在发出下一条指令之前应等待的时钟周期数，范围从0到15个周期。在Pascal和Maxwell上，如果该字段与让出标志的组合具有特殊的位组合，则一个处理块中的两个调度器可以同时调度一个线程的两条连续指令（双重调度）。在Turing和Volta上，每个处理块中只有一个调度器，我们在生成的代码中没有观察到双重调度。

让出标志。与前代产品一样，Turing架构使用一个1位的让出标志来平衡分配给处理块的工作负载。当该位被设置时，调度器更倾向于从当前线程中发出下一条指令。当该位被清除时，调度器更倾向于切换到另一个线程，从而使下一条指令的所有寄存器重用标志失效。这种切换需要额外的一个时钟周期。

#### 2.2 处理块和调度器

Turing的流式多处理器（SM）被划分为四个处理块，每个块包含一个专用的线程调度器和分发单元。来自同一线程的指令被分配到特定的处理块中，且只能访问该块内的处理单元。

我们发现，在Turing和Volta上，线程被映射到调度器（和处理块）的规则与Volta相同，具体如下：

\[
\text{warp\_index} \mod 4
\]

这一结论通过以下实验得到验证：在一个SM上同时运行8个线程，其中只有2个线程是活跃的，它们执行循环的`FFMA`指令，而其余6个线程处于空闲状态。

我们通过改变两个活跃线程（线程A和线程B）的索引，重复实验，并测量每次两个线程的聚合算术吞吐量。结果（见表2.1）表明，当两个线程的索引在模4下相同时（例如，0和4、1和5等），它们的聚合性能下降，这表明它们被映射到了同一个调度器。

这些发现与Turing和Volta之间是一致的。

此外，这些结果表明，你的工作负载的每个块必须至少使用128个线程，才能充分利用Turing和Volta上一个SM的处理单元。

#### 2.3 指令字格式

##### 2.3.1 操作码

Turing和Volta使用的指令编码位数比之前的架构更多。

与之前的架构（Pascal、Maxwell和Kepler）不同，这些架构将操作码放在指令的最高有效位，而Turing和Volta架构将操作码放在第一个64位字的最低有效位。Turing的操作码长度在10到13位之间变化。有关比较Pascal、Volta和Turing的详细操作码参考，请参阅附录。

##### 2.3.2 操作数

与之前的架构一样，Turing上的指令操作数可以是不同类型的寄存器、内存地址（常量、共享或全局）或一个立即数。谓词由4位控制：第一位是一个取反标志，其余3位编码谓词寄存器索引。
